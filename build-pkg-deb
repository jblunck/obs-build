#
# Debian dpkg specific functions.
#
################################################################
#
# Copyright (c) 1995-2014 SUSE Linux Products GmbH
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 or 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program (see the file COPYING); if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
#
################################################################

#
# A wrapper around chroot to set the environment correctly for dpkg and
# pre/postinst scripts.
#
deb_chroot ()
{
    #
    # to workaround some version of fileutils that doesn't do a 'chdir /'
    # when doing a 'chroot /' call lets subshell and change dir manually
    #
    (
	cd $1 &&
	    DEBIAN_FRONTEND=noninteractive DEBIAN_PRIORITY=critical \
			   DEBCONF_NONINTERACTIVE_SEEN=true \
			   LC_ALL=C LANGUAGE=C LANG=C \
			   chroot $*
    )
}

deb_setup() {
    mkdir -p $BUILD_ROOT/var/lib/dpkg
    mkdir -p $BUILD_ROOT/var/log
    mkdir -p $BUILD_ROOT/etc/default
    :>> $BUILD_ROOT/var/lib/dpkg/status
    :>> $BUILD_ROOT/var/lib/dpkg/available
    :>> $BUILD_ROOT/var/log/dpkg.log
    :>> $BUILD_ROOT/etc/ld.so.conf
    :>> $BUILD_ROOT/etc/default/rcS
}

pkg_preinstall_deb() {
    dpkg-deb --extract "$BUILD_ROOT/.init_b_cache/rpms/$PKG.deb" "$BUILD_ROOT"

    if test -e ".init_b_cache/scripts/$PKG.run" ; then
	dpkg-deb --control "$BUILD_ROOT/.init_b_cache/rpms/$PKG.deb" \
		 .init_b_cache/scripts/control
	mv .init_b_cache/scripts/control/preinst \
	   ".init_b_cache/scripts/$PKG.pre" 2>/dev/null || true
	mv .init_b_cache/scripts/control/postinst \
	   ".init_b_cache/scripts/$PKG.post" 2>/dev/null || true
	rm -rf .init_b_cache/scripts/control
    fi
}

pkg_runscripts_deb() {
    if ! test -e $BUILD_ROOT/var/lib/dpkg/status ; then
	deb_setup
    fi
    if test -e "$BUILD_ROOT/.init_b_cache/scripts/$PKG.pre" ; then
	echo "running $PKG preinstall script"
	deb_chroot $BUILD_ROOT ".init_b_cache/scripts/$PKG.pre" install \
		   < /dev/null
	rm -f "$BUILD_ROOT/.init_b_cache/scripts/$PKG.pre"
    fi
    if test -e "$BUILD_ROOT/.init_b_cache/scripts/$PKG.post" ; then
	echo "running $PKG postinstall script"
	deb_chroot $BUILD_ROOT ".init_b_cache/scripts/$PKG.post" configure '' \
		   < /dev/null
	rm -f "$BUILD_ROOT/.init_b_cache/scripts/$PKG.post"
    fi
}

# unpack and move to $BUILD_ROOT/.init_b_cache/debootstrap
debootstrap_unpack() {
    local DIR=${1?missing argument}
    local PKG_DIR=$BUILD_ROOT/.init_b_cache/debootstrap.pkg

    rm -fr $DIR $PKG_DIR
    dpkg-deb --extract $BUILD_ROOT/.init_b_cache/rpms/debootstrap.deb $PKG_DIR
    mv $PKG_DIR/usr/share/debootstrap $DIR
    mv $PKG_DIR/usr/sbin/debootstrap $DIR/debootstrap
    chmod 755 $DIR/debootstrap
    rm -fr $PKG_DIR
}

#
# init_buildsystem already:
# - preinstalled packages
# - created devices
#
# what is left to do:
# - create dpkg database
# - foreign install of dpkg itself
#
debootstrap_first_stage ()
{
    local ARCH=${1?missing argument}
    local SUITE=${2?missing argument}

    #
    # finddebs/dldebs downloads the indices (we don't care of)
    #
    local APT_LISTS="$BUILD_ROOT/var/lib/apt/lists"
    mkdir -p ${APT_LISTS}
    touch "${APT_LISTS}/debootstrap.invalid_dists_${SUITE}_Release"
    touch "${APT_LISTS}/debootstrap.invalid_dists_${SUITE}_main_binary-${ARCH}_Packages"

    mkdir -p "$BUILD_ROOT/var/lib/dpkg/info"
    : >"$BUILD_ROOT/var/lib/dpkg/status"
    : >"$BUILD_ROOT/var/lib/dpkg/available"

    # foreign install of dpkg
    local DPKG_DEB=$BUILD_ROOT/.init_b_cache/rpms/dpkg.deb
    cat > $BUILD_ROOT/var/lib/dpkg/status <<EOF
Package: dpkg
Version: $(dpkg-deb --field ${DPKG_DEB} Version)
Maintainer: unknown
Architecture: $(dpkg-deb --field ${DPKG_DEB} Architecture)
Status: install ok installed
Description: unknown
EOF
    touch $BUILD_ROOT/var/lib/dpkg/info/dpkg.list
}

debootstrap_second_stage_prepare ()
{
    local ARCH=${1?missing argument}
    local SUITE=${2?missing argument}

    echo "${ARCH}"            >$BUILD_ROOT/debootstrap/arch
    echo "${SUITE}"           >$BUILD_ROOT/debootstrap/suite
    ln -sf "scripts/${SUITE}"  $BUILD_ROOT/debootstrap/suite-script
    echo "minbase"            >$BUILD_ROOT/debootstrap/variant

    # all required package should be listed as preinstall
    echo "$PACKAGES_TO_PREINSTALL" >$BUILD_ROOT/debootstrap/required

    # all other packages are treated as base packages
    echo "$PACKAGES_TO_INSTALL" >$BUILD_ROOT/debootstrap/base

    # create archive with hardlinks that are removed once debootstrap finishes
    mkdir -p $BUILD_ROOT/debootstrap/archives
    ln -L $BUILD_ROOT/.init_b_cache/rpms/* $BUILD_ROOT/debootstrap/archives/
    for pkg in $(find $BUILD_ROOT/debootstrap/archives -name '*.deb') ; do
        local name=$(dpkg-deb --field $pkg Package)

        echo $name ${pkg##$BUILD_ROOT}
    done > $BUILD_ROOT/debootstrap/debpaths
}

debootstrap_suite() {
    local DEBIAN_VERSION=$(cat $BUILD_ROOT/etc/debian_version)

    case "${DEBIAN_VERSION}" in
        7.*)
            echo "wheezy"
            ;;
        8.*)
            echo "jessie"
            ;;
        9.*)
            echo "stretch"
            ;;
        *)
            echo ${DEBIAN_VERSION%%/*}
            ;;
    esac
}

pkg_initdb_deb() {
    deb_setup

    local ARCH=$(deb_chroot $BUILD_ROOT dpkg --print-architecture)
    local SUITE=$(debootstrap_suite)

    if ! test -r $BUILD_ROOT/.init_b_cache/rpms/debootstrap.deb ; then
	# force dpkg into database to make epoch test work
	if ! test "$BUILD_ROOT/.init_b_cache/rpms/dpkg.deb" -ef "$BUILD_ROOT/.init_b_cache/dpkg.deb" ; then
	    rm -f $BUILD_ROOT/.init_b_cache/dpkg.deb
	    cp $BUILD_ROOT/.init_b_cache/rpms/dpkg.deb $BUILD_ROOT/.init_b_cache/dpkg.deb || cleanup_and_exit 1
	fi
	deb_chroot $BUILD_ROOT dpkg --install --force-depends .init_b_cache/dpkg.deb >/dev/null 2>&1
    else
	debootstrap_unpack $BUILD_ROOT/debootstrap
	debootstrap_first_stage ${ARCH} ${SUITE}
	debootstrap_second_stage_prepare ${ARCH} ${SUITE}

	deb_chroot $BUILD_ROOT /debootstrap/debootstrap \
		   --second-stage --no-check-gpg
    fi
}

pkg_prepare_deb() {
    :
}

pkg_install_deb() {
    ( deb_chroot $BUILD_ROOT dpkg --install --force-depends .init_b_cache/$PKG.deb 2>&1 || touch $BUILD_ROOT/exit ) | \
	perl -ne '$|=1;/^(Configuration file|Installing new config file|Selecting previously deselected|Selecting previously unselected|\(Reading database|Unpacking |Setting up|Creating config file|Preparing to replace dpkg|Preparing to unpack )/||/^$/||print'
    # ugly workaround for upstart system. some packages (procps) try
    # to start a service in their configure phase. As we don't have
    # a running upstart, we just link the start binary to /bin/true
    if test -e "$BUILD_ROOT/sbin/start"; then
	if test "$BUILD_ROOT/sbin/start" -ef "$BUILD_ROOT/sbin/initctl" ; then
	    echo "linking /sbin/start to /bin/true"
	    mv "$BUILD_ROOT/sbin/start" "$BUILD_ROOT/sbin/start.disabled"
	    ln -s "/bin/true" "$BUILD_ROOT/sbin/start"
	fi
    fi
    # another workaround, see bug bnc#733699
    rm -f "$BUILD_ROOT/var/run/init.upgraded"
}

pkg_erase_deb() {
    deb_chroot $BUILD_ROOT dpkg --purge --force-depends $PKG 2>&1 | {
      local retry
      while read line; do
          case "$line" in
              subprocess\ installed\ *script\ returned\ error\ exit\ status*)
                 chroot $BUILD_ROOT rm -f /var/lib/dpkg/info/$PKG.{pre,post}rm
                 retry=1
              ;;
              *) echo "$line" ;;
          esac
      done
      if test -n "$retry"; then
          echo "re-try deleting $PKG without post/pre remove scripts"
          deb_chroot $BUILD_ROOT dpkg --purge --force-depends $PKG 2>&1 || touch $BUILD_ROOT/exit
      fi
    } | perl -ne '$|=1;/^(\(Reading database|Removing |Purging configuration files for )/||/^$/||print'
}

pkg_cumulate_deb() {
    return 1
}

pkg_verify_installed_deb() {
    return 1
}

pkg_finalize_deb() {
    echo "configuring all installed packages..."
    # configure all packages after complete installation, not for each package like rpm does
    # We need to run this twice, because of cyclic dependencies as it does not succeed on most
    # debian based distros in the first attempt.
    if ! deb_chroot $BUILD_ROOT dpkg --configure --pending  2>&1; then
         echo "first configure attempt failed, trying again..."
         deb_chroot $BUILD_ROOT dpkg --configure --pending  2>&1 || cleanup_and_exit 1
    fi
}

# Local Variables:
# mode: Shell-script
# End:
